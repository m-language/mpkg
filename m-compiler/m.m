(def id (fn x x))
(def normalize id)
(def unnormalize id)
(def const (fn x (fn _ x)))
(def desugar-fn-declaration (const ()))
(def compose (fn f (fn g (fn x (f (g x))))))
(def swap (fn f (fn x (fn y ((f y) x)))))
(def apply (fn f (fn x (f x))))
(def with (swap apply))
(def left (fn value (fn f (fn _ (f value)))))
(def right (fn value (fn _ (fn f (f value)))))
(def some right)
(def true (fn x (fn _ x)))
(def false (fn _ (fn x x)))
(def null (left false))
(def empty-heap (const null))
(def right? (fn either ((either (const false)) (const true))))
(def some? right?)
(def left? (fn either ((either (const true)) (const false))))
(def null? left?)
(def result/success (fn expr (left expr)))
(def pair (fn first (fn second (fn bool ((bool first) second)))))
(def first (fn pair (pair true)))
(def type-name first)
(def second (fn pair (pair false)))
(def symbol-expr? first)
(def nil ())
(def cons pair)
(def symbol-expr (fn name (fn path (fn start (fn end ((pair true) ((cons name) ((cons path) ((cons start) ((cons end) ()))))))))))
(def list-expr (fn exprs (fn path (fn start (fn end ((pair false) ((cons exprs) ((cons path) ((cons start) ((cons end) ()))))))))))
(def car first)
(def symbol-expr.name ((compose car) second))
(def list-expr.exprs ((compose car) second))
(def cdr second)
(def cddr ((compose cdr) cdr))
(def cdddr ((compose cdr) cddr))
(def cadr ((compose car) cdr))
(def symbol-expr.path ((compose cadr) second))
(def list-expr.path ((compose cadr) second))
(def caddr ((compose car) cddr))
(def symbol-expr.start ((compose caddr) second))
(def list-expr.start ((compose caddr) second))
(def cadddr ((compose car) cdddr))
(def symbol-expr.end ((compose cadddr) second))
(def list-expr.end ((compose cadddr) second))
(def nil? (fn list ((list (const (const (const false)))) true)))
(def position pair)
(def position.line first)
(def position.char second)
(def nat.0 (fn f (fn x x)))
(def nat.1 (fn f (fn x (f x))))
(def start-position ((position nat.1) nat.1))
(def expr/symbol (fn name ((((symbol-expr name) (symbol expr.m)) start-position) start-position)))
(def expr/list (fn exprs ((((list-expr exprs) (symbol expr.m)) start-position) start-position)))
(def delay (fn env (fn exprs (result/success (expr/list ((cons (expr/symbol (symbol fn))) ((cons (expr/symbol (symbol _))) exprs)))))))
(def list (fn env (fn exprs (result/success (expr/list ((((nil? exprs) (const ())) (fn _ ((cons (expr/symbol (symbol cons))) ((cons (car exprs)) ((cons (expr/list ((cons (expr/symbol (symbol list))) (cdr exprs)))) ()))))) ()))))))
(def success (left ()))
(def m:test (fn _ success))
(def apply-vararg (fn env (fn exprs (result/success (expr/list ((cons (car exprs)) ((cons (expr/list ((cons (expr/symbol (symbol list))) (cdr exprs)))) ())))))))
(def if (fn env (fn exprs (result/success (expr/list ((cons (expr/symbol (symbol force))) ((cons (expr/list ((cons (car exprs)) ((cons (expr/list ((cons (expr/symbol (symbol delay))) ((cons (cadr exprs)) ())))) ((cons (expr/list ((cons (expr/symbol (symbol delay))) ((cons (caddr exprs)) ())))) ()))))) ())))))))
(def macrofn (fn env (fn exprs (result/success (expr/list ((cons (expr/symbol (symbol macro))) ((cons (car exprs)) ((cons (expr/list ((cons (expr/symbol (symbol fn))) (cdr exprs)))) ()))))))))
(def & (fn env (fn exprs (result/success (expr/list ((cons (expr/symbol (symbol and))) ((cons (car exprs)) ((cons (expr/list ((cons (expr/symbol (symbol delay))) ((cons (cadr exprs)) ())))) ()))))))))
(def | (fn env (fn exprs (result/success (expr/list ((cons (expr/symbol (symbol or))) ((cons (car exprs)) ((cons (expr/list ((cons (expr/symbol (symbol delay))) ((cons (cadr exprs)) ())))) ()))))))))
(def defn (fn env (fn exprs (result/success (expr/list ((cons (expr/symbol (symbol def))) ((cons (car exprs)) ((cons (expr/list ((cons (expr/symbol (symbol fn))) (cdr exprs)))) ()))))))))
(def desugar-nil-operation (fn desugar-operation (fn operation (symbol ""()""))))
(def interpret-nil-operation (fn interpret-operation' (fn operation (fn stack (fn heap ())))))
(def unnull (fn either ((either id) id)))
(def result/error (fn error (right (left error))))
(def result/depends (fn dependencies (right (right dependencies))))
(def result/match (fn result (fn success (fn error (fn depends ((result success) (fn fail ((fail error) depends))))))))
(def nat.0? (fn n ((n (const true)) false)))
(def nat.inc (fn n (fn f (fn x (f ((n f) x))))))
(def nat.dec (fn n (fn f (fn x (((n (fn g (fn h (h (g f))))) (const x)) id)))))
(def failure (fn messages (right messages)))
(def fail (fn message (failure ((cons message) ()))))
(def extern (fn env (fn exprs (result/success (expr/list ((cons (expr/symbol (symbol def))) ((cons (car exprs)) ((cons (car exprs)) ()))))))))
(def jvm-backend jvm-backend)
(def mangle-fn-name mangle-fn-name)
(def mpm-root mpm-root)
(def assert (fn env (fn exprs (result/success (expr/list ((cons (expr/symbol (symbol delay))) ((cons (expr/list ((cons (expr/symbol (symbol test-condition))) ((cons (car exprs)) ((cons (expr/list ((cons (expr/symbol (symbol symbol))) ((cons (expr/symbol (symbol ""Assertion failed""))) ())))) ()))))) ())))))))
(def assert-not (fn env (fn exprs (result/success (expr/list ((cons (expr/symbol (symbol assert))) ((cons (expr/list ((cons (expr/symbol (symbol not))) ((cons (car exprs)) ())))) ())))))))
(def force (fn env (fn exprs (result/success (expr/list ((cons (car exprs)) ((cons (expr/list ())) ())))))))
(def macro-call-expr (fn env (fn exprs ((((nil? exprs) (fn _ (result/error (symbol ""No exprs passed to macro-call-expr"")))) (fn _ (result/success (expr/list ((cons (expr/symbol (symbol expr/list))) ((cons (expr/list ((cons (expr/symbol (symbol cons))) ((cons (expr/list ((cons (expr/symbol (symbol expr/symbol))) ((cons (expr/list ((cons (expr/symbol (symbol symbol))) ((cons (car exprs)) ())))) ())))) ((cons (cadr exprs)) ()))))) ())))))) ()))))
(def cond (fn env (fn exprs ((((nil? exprs) (fn _ (result/error (symbol ""No exprs passed to cond"")))) (fn _ ((((nil? (cdr exprs)) (fn _ (result/success (car exprs)))) (fn _ ((((nil? (cddr exprs)) (fn _ (result/error (symbol ""No else case for cond"")))) (fn _ (result/success (expr/list ((cons (expr/symbol (symbol if))) ((cons (car exprs)) ((cons (cadr exprs)) ((cons (expr/list ((cons (expr/symbol (symbol cond))) (cddr exprs)))) ())))))))) ()))) ()))) ()))))
(def nat.= (fn a (fn b ((((nat.0? a) (fn _ (nat.0? b))) (fn _ ((((nat.0? b) (fn _ false)) (fn _ ((nat.= (nat.dec a)) (nat.dec b)))) ()))) ()))))
(def and (fn x (fn y (((x (fn _ (y ()))) (fn _ false)) ()))))
(def list.= (fn = (fn a (fn b ((((nil? a) (fn _ (nil? b))) (fn _ ((((nil? b) (fn _ false)) (fn _ ((and ((= (car a)) (car b))) (fn _ (((list.= =) (cdr a)) (cdr b)))))) ()))) ())))))
(def or (fn x (fn y (((x (fn _ true)) (fn _ (y ()))) ()))))
(def not (fn x (((x (fn _ false)) (fn _ true)) ())))
(def list-expr? ((compose not) first))
(def nat.< (fn a (fn b ((((nat.0? a) (fn _ (not (nat.0? b)))) (fn _ ((((nat.0? b) (fn _ false)) (fn _ ((nat.< (nat.dec a)) (nat.dec b)))) ()))) ()))))
(def nat.> (swap nat.<))
(def expr.path (fn expr ((((list-expr? expr) (fn _ (list-expr.path expr))) (fn _ (symbol-expr.path expr))) ())))
(def expr.start (fn expr ((((list-expr? expr) (fn _ (list-expr.start expr))) (fn _ (symbol-expr.start expr))) ())))
(def expr.end (fn expr ((((list-expr? expr) (fn _ (list-expr.end expr))) (fn _ (symbol-expr.end expr))) ())))
(def init (fn list ((((nil? (cdr list)) (fn _ ())) (fn _ ((cons (car list)) (init (cdr list))))) ())))
(def last (fn list ((((nil? (cdr list)) (fn _ (car list))) (fn _ (last (cdr list)))) ())))
(def append (fn list (fn elem ((((nil? list) (fn _ ((cons elem) ()))) (fn _ ((cons (car list)) ((append (cdr list)) elem)))) ()))))
(def concat (fn a (fn b ((((nil? a) (fn _ b)) (fn _ ((cons (car a)) ((concat (cdr a)) b)))) ()))))
(def get (fn list (fn n ((((nat.0? n) (fn _ (car list))) (fn _ ((get (cdr list)) (nat.dec n)))) ()))))
(def map (fn list (fn f ((((nil? list) (fn _ ())) (fn _ ((cons (f (car list))) ((map (cdr list)) f)))) ()))))
(def expr.with-path (fn path (fn expr ((((symbol-expr? expr) (fn _ ((((symbol-expr (symbol-expr.name expr)) path) (symbol-expr.start expr)) (symbol-expr.end expr)))) (fn _ ((((list-expr ((map (list-expr.exprs expr)) (expr.with-path path))) path) (list-expr.start expr)) (list-expr.end expr)))) ()))))
(def flat-map (fn list (fn f ((((nil? list) (fn _ ())) (fn _ ((concat (f (car list))) ((flat-map (cdr list)) f)))) ()))))
(def filter (fn list (fn f ((((nil? list) (fn _ ())) (fn _ ((((f (car list)) (fn _ ((cons (car list)) ((filter (cdr list)) f)))) (fn _ ((filter (cdr list)) f))) ()))) ()))))
(def fold (fn list (fn acc (fn f ((((nil? list) (fn _ acc)) (fn _ (((fold (cdr list)) ((f acc) (car list))) f))) ())))))
(def combine-tests (fn tests (fn _ (((fold tests) success) (fn state (fn test (((test ()) (const state)) (fn failure1 ((state (fn _ (failure failure1))) (fn failure2 (failure ((concat failure1) failure2))))))))))))
(def reverse' (fn list (fn acc ((((nil? list) (fn _ acc)) (fn _ ((reverse' (cdr list)) ((cons (car list)) acc)))) ()))))
(def reverse (fn list ((reverse' list) ())))
(def nat.+ (fn a (fn b ((((nat.0? b) (fn _ a)) (fn _ ((nat.+ (nat.inc a)) (nat.dec b)))) ()))))
(def next-char (fn p ((position (position.line p)) ((nat.+ nat.1) (position.char p)))))
(def next-line (fn p ((position ((nat.+ nat.1) (position.line p))) nat.1)))
(def nat.- (fn a (fn b ((((nat.0? b) (fn _ a)) (fn _ ((nat.- (nat.dec a)) (nat.dec b)))) ()))))
(def test-condition (fn condition (fn message (((condition (fn _ success)) (fn _ (fail message))) ()))))
(def char->nat id)
(def char.= nat.=)
(def open-parentheses (car (symbol ""("")))
(def close-parentheses (car (symbol "")"")))
(def semicolon (car (symbol "";"")))
(def dot (car (symbol .)))
(def quote (car (symbol """ "")))
(def slash (car (symbol /)))
(def backslash (car (symbol ""\"")))
(def space (car (symbol "" "")))
(def tab (car (symbol ""	"")))
(def linefeed (car (symbol ""
"")))
(def carriage-return (car (symbol ""
"")))
(def newline? (fn char ((or ((char.= char) linefeed)) (fn _ ((char.= char) carriage-return)))))
(def parse-comment (fn path (fn input (fn position (fn continue (((((or (nil? input)) (fn _ (newline? (car input)))) (fn _ (((continue path) input) position))) (fn _ ((((parse-comment path) (cdr input)) (next-char position)) continue))) ()))))))
(def whitespace? (fn char ((or ((char.= char) space)) (fn _ ((or ((char.= char) tab)) (fn _ (newline? char)))))))
(def separator? (fn char ((or (whitespace? char)) (fn _ ((or ((char.= char) open-parentheses)) (fn _ ((or ((char.= char) close-parentheses)) (fn _ ((or ((char.= char) semicolon)) (fn _ ((char.= char) quote)))))))))))
(def impure (fn x (fn f (f x))))
(def then-run-with (fn p (fn f (p f))))
(def then-run (fn a (fn b ((then-run-with a) (const b)))))
(def run-with (fn p (fn f ((then-run-with p) ((compose impure) f)))))
(def do (fn env (fn exprs (result/success ((((nil? (cdr exprs)) (fn _ (expr/list exprs))) (fn _ (expr/list ((cons (expr/symbol (symbol then-run-with))) ((cons (cadr exprs)) ((cons (expr/list ((cons (expr/symbol (symbol fn))) ((cons (car exprs)) ((cons (expr/list ((cons (expr/symbol (symbol do))) (cddr exprs)))) ()))))) ())))))) ())))))
(def process/sequence (fn list ((then-run-with (car list)) (fn head ((then-run-with (process/sequence (cdr list))) (fn tail (impure ((cons head) tail))))))))
(def symbol->list id)
(def object (fn type ((pair type) (fn name ((concat (symbol->list (symbol ""Could not find field ""))) ((concat (symbol->list name)) ((concat (symbol->list (symbol "" for ""))) (symbol->list type))))))))
(def nil-operation (object (symbol nil-operation)))
(def tree-map-node-nil (object (symbol tree-map-node-nil)))
(def symbol.= (list.= char.=))
(def is? (fn type (fn data ((symbol.= type) (type-name data)))))
(def def-declaration? (is? (symbol def-declaration)))
(def fn-declaration? (is? (symbol fn-declaration)))
(def local-variable? (is? (symbol local-variable)))
(def global-variable? (is? (symbol global-variable)))
(def generating? (is? (symbol generating)))
(def generated? (is? (symbol generated)))
(def degenerate? (is? (symbol degenerate)))
(def tree-map-node-nil? (is? (symbol tree-map-node-nil)))
(def derive (fn data (fn name (fn value ((pair (first data)) (fn field (((((symbol.= field) name) (fn _ value)) (fn _ ((second data) field))) ())))))))
(def data (fn type (fn fields (((fold fields) (object type)) (fn data (fn field (((derive data) (first field)) (second field))))))))
(def new-data' (fn type (fn names (fn fields ((((nil? names) (fn _ ((data type) fields))) (fn _ (fn value (((new-data' type) (cdr names)) ((cons ((pair (car names)) value)) fields))))) ())))))
(def new-data (fn type (fn names (((new-data' type) names) ()))))
(def def-declaration ((new-data (symbol def-declaration)) ((cons (symbol name)) ((cons (symbol path)) ((cons (symbol value)) ())))))
(def fn-declaration ((new-data (symbol fn-declaration)) ((cons (symbol name)) ((cons (symbol path)) ((cons (symbol closures)) ((cons (symbol value)) ()))))))
(def local-env ((new-data (symbol local-env)) ((cons (symbol locals)) ((cons (symbol def)) ()))))
(def global-env ((new-data (symbol global-env)) ((cons (symbol globals)) ((cons (symbol heap)) ((cons (symbol dependents)) ((cons (symbol index)) ()))))))
(def local-variable-operation ((new-data (symbol local-variable-operation)) ((cons (symbol name)) ((cons (symbol index)) ()))))
(def global-variable-operation ((new-data (symbol global-variable-operation)) ((cons (symbol name)) ((cons (symbol path)) ()))))
(def if-operation ((new-data (symbol if-operation)) ((cons (symbol cond)) ((cons (symbol true)) ((cons (symbol false)) ())))))
(def def-operation ((new-data (symbol def-operation)) ((cons (symbol name)) ((cons (symbol path)) ((cons (symbol value)) ())))))
(def fn-operation ((new-data (symbol fn-operation)) ((cons (symbol path)) ((cons (symbol name)) ((cons (symbol arg)) ((cons (symbol value)) ((cons (symbol closures)) ())))))))
(def symbol-operation ((new-data (symbol symbol-operation)) ((cons (symbol name)) ())))
(def apply-operation ((new-data (symbol apply-operation)) ((cons (symbol fn)) ((cons (symbol arg)) ()))))
(def line-number-operation ((new-data (symbol line-number-operation)) ((cons (symbol operation)) ((cons (symbol line)) ()))))
(def local-variable ((new-data (symbol local-variable)) ((cons (symbol name)) ((cons (symbol index)) ()))))
(def global-variable ((new-data (symbol global-variable)) ((cons (symbol name)) ((cons (symbol path)) ((cons (symbol macro?)) ())))))
(def generating ((new-data (symbol generating)) ((cons (symbol dependencies)) ((cons (symbol global-env)) ((cons (symbol continue)) ())))))
(def generated ((new-data (symbol generated)) ((cons (symbol operation)) ((cons (symbol declarations)) ((cons (symbol global-env)) ())))))
(def generate-nil (fn local-env (fn global-env (((generated nil-operation) ()) global-env))))
(def generate-symbol-literal-expr (fn name (fn local-env (fn global-env (((generated (symbol-operation name)) ()) global-env)))))
(def degenerate ((new-data (symbol degenerate)) ((cons (symbol errors)) ((cons (symbol global-env)) ()))))
(def tree-map-node ((new-data (symbol tree-map-node)) ((cons (symbol left)) ((cons (symbol right)) ((cons (symbol key)) ((cons (symbol value)) ()))))))
(def tree-map ((new-data (symbol tree-map)) ((cons (symbol node)) ((cons (symbol compare)) ()))))
(def empty-tree-map (fn compare ((tree-map tree-map-node-nil) compare)))
(def symbol.+ concat)
(def ostream.write (fn ostream (fn char (ostream char))))
(def ostream.writeln (fn ostream (fn line ((((nil? line) (fn _ ((ostream.write ostream) linefeed))) (fn _ ((then-run ((ostream.write ostream) (car line))) ((ostream.writeln ostream) (cdr line))))) ()))))
(def stdout stdout)
(def stderr stderr)
(def run-test (fn test (((test ()) (fn success ((ostream.writeln stdout) (symbol ""Tests successful"")))) (fn failure (((fold failure) (impure ())) (fn process (fn message ((then-run process) ((ostream.writeln stderr) message)))))))))
(def stdin stdin)
(def debug debug)
(def let (fn env (fn exprs (result/success ((((nil? (cdr exprs)) (fn _ (expr/list exprs))) (fn _ (expr/list ((cons (expr/symbol (symbol with))) ((cons (cadr exprs)) ((cons (expr/list ((cons (expr/symbol (symbol fn))) ((cons (car exprs)) ((cons (expr/list ((cons (expr/symbol (symbol let))) (cddr exprs)))) ()))))) ())))))) ())))))
(def parse-symbol (fn path (fn input (fn position (fn continue ((with (car input)) (fn head (((((or (nil? input)) (fn _ (separator? head))) (fn _ ((((continue ()) path) input) position))) (fn _ ((((parse-symbol path) (cdr input)) (next-char position)) (fn chars (fn path (fn input (fn position ((((continue ((cons head) chars)) path) input) position)))))))) ()))))))))
(def pcond (fn env (fn exprs ((((nil? exprs) (fn _ (result/error (symbol ""No exprs passed to pcond"")))) (fn _ ((with (car exprs)) (fn predicate ((with (cdr exprs)) (fn vals ((((nil? vals) (fn _ (result/error (symbol ""No values after predicate for pcond"")))) (fn _ ((((nil? (cdr vals)) (fn _ (result/success (car vals)))) (fn _ (result/success (expr/list ((cons (expr/symbol (symbol if))) ((cons (expr/list ((cons predicate) ((cons (car vals)) ())))) ((cons (cadr vals)) ((cons (expr/list ((cons (expr/symbol (symbol pcond))) ((cons predicate) (cddr vals))))) ())))))))) ()))) ()))))))) ()))))
(def desugar-should-quote? (fn name ((((nil? name) (fn _ false)) (fn _ ((with (car name)) (fn char ((or ((char.= char) quote)) (fn _ ((or ((char.= char) backslash)) (fn _ ((or ((char.= char) open-parentheses)) (fn _ ((or ((char.= char) close-parentheses)) (fn _ ((or ((char.= char) semicolon)) (fn _ ((or (whitespace? char)) (fn _ (desugar-should-quote? (cdr name)))))))))))))))))) ())))
(def desugar-quote (fn name (((((or (desugar-should-quote? name)) (fn _ (nil? name))) (fn _ ((cons quote) ((cons quote) (((swap append) quote) (((swap append) quote) name)))))) (fn _ name)) ())))
(def parse-unused (fn path (fn input (fn position (fn continue ((((nil? input) (fn _ (((continue path) input) position))) (fn _ ((with (car input)) (fn head (((((char.= head) linefeed) (fn _ ((((parse-unused path) (cdr input)) (next-line position)) continue))) (fn _ ((((whitespace? head) (fn _ ((((parse-unused path) (cdr input)) (next-char position)) continue))) (fn _ (((((char.= head) semicolon) (fn _ ((((parse-comment path) (cdr input)) (next-char position)) (fn path (fn input (fn position ((((parse-unused path) input) position) continue))))))) (fn _ (((continue path) input) position))) ()))) ()))) ()))))) ()))))))
(def istream.read id)
(def istream.readln (fn istream ((then-run-with istream) (fn char (((((char.= linefeed) char) (fn _ (impure ()))) (fn _ ((then-run-with (istream.readln istream)) (fn line (impure ((((newline? char) (fn _ line)) (fn _ ((cons char) line))) ())))))) ())))))
(def compare= (object (symbol compare=)))
(def compare< (object (symbol compare<)))
(def compare> (object (symbol compare>)))
(def compare-nat (fn a (fn b (((((nat.> a) b) (fn _ compare>)) (fn _ (((((nat.< a) b) (fn _ compare<)) (fn _ compare=)) ()))) ()))))
(def compare-char (fn a (fn b ((compare-nat (char->nat a)) (char->nat b)))))
(def compare=? (is? (symbol compare=)))
(def compare-list (fn compare (fn a (fn b (((((and (nil? a)) (fn _ (nil? b))) (fn _ compare=)) (fn _ ((((nil? a) (fn _ compare<)) (fn _ ((((nil? b) (fn _ compare>)) (fn _ ((with ((compare (car a)) (car b))) (fn compare-result ((((compare=? compare-result) (fn _ (((compare-list compare) (cdr a)) (cdr b)))) (fn _ compare-result)) ()))))) ()))) ()))) ())))))
(def compare-symbol (fn a (fn b (((compare-list compare-char) a) b))))
(def default-local-env ((local-env (empty-tree-map compare-symbol)) ()))
(def default-global-env ((((global-env (empty-tree-map compare-symbol)) empty-heap) (empty-tree-map compare-symbol)) nat.0))
(def compare<? (is? (symbol compare<)))
(def compare>? (is? (symbol compare>)))
(def fold-compare (fn compare (fn < (fn > (fn = ((((compare<? compare) (fn _ (< compare))) (fn _ ((((compare>? compare) (fn _ (> compare))) (fn _ (= compare))) ()))) ()))))))
(def file.from-path file.from-path)
(def file.local-file (file.from-path (symbol .)))
(def file.name file.name)
(def file.name-without-extension file.name-without-extension)
(def file.child file.child)
(def ref-root (fn root ((file.child root) (symbol ref))))
(def mpm-ref-root (ref-root mpm-root))
(def src-root (fn root ((file.child root) (symbol src))))
(def mpm-src-root (src-root mpm-root))
(def get-ref (fn ref-root (fn name ((file.child ref-root) (normalize name)))))
(def mpm-get-ref (get-ref mpm-ref-root))
(def get-src (fn src-root (fn ref ((file.child src-root) ((concat ref) (symbol .m))))))
(def mpm-get-src (get-src mpm-src-root))
(def file.exists? file.exists?)
(def file.read file.read)
(def file.write file.write)
(def file.directory? file.directory?)
(def file.child-files file.child-files)
(def file.copy file.copy)
(def put-srcs (fn in (fn src-root ((file.copy in) src-root))))
(def mpm-put-srcs (fn in ((put-srcs in) mpm-src-root)))
(def error (fn message (fn _ (error message))))
(def parse-single-quote (fn path (fn input (fn position (fn continue ((((nil? input) (fn _ (error (symbol ""Unexpected end of file"")))) (fn _ ((with (car input)) (fn head (((((char.= head) quote) (fn _ ((((continue ()) path) (cdr input)) (next-char position)))) (fn _ ((((parse-single-quote path) (cdr input)) ((((((char.= head) linefeed) (fn _ next-line)) (fn _ next-char)) ()) position)) (fn chars (fn path (fn input (fn position ((((continue ((cons head) chars)) path) input) position)))))))) ()))))) ()))))))
(def parse-double-quote (fn path (fn input (fn position (fn continue ((((nil? input) (fn _ (error (symbol ""Unexpected end of file"")))) (fn _ ((with (car input)) (fn head (((((and ((char.= head) quote)) (fn _ ((char.= (cadr input)) quote))) (fn _ ((((continue ()) path) (cddr input)) (next-char (next-char position))))) (fn _ ((((parse-double-quote path) (cdr input)) ((((((char.= head) linefeed) (fn _ next-line)) (fn _ next-char)) ()) position)) (fn chars (fn path (fn input (fn position ((((continue ((cons head) chars)) path) input) position)))))))) ()))))) ()))))))
(def parse-symbol-literal (fn path (fn input (fn position (fn continue ((((nil? input) (fn _ (error (symbol ""Unexpected end of file"")))) (fn _ (((((char.= (car input)) quote) (fn _ ((((parse-double-quote path) (cdr input)) (next-char position)) continue))) (fn _ ((((parse-single-quote path) input) position) continue))) ()))) ()))))))
(def parse-list (fn parse-expr (fn path (fn input (fn position (fn continue ((((nil? input) (fn _ (error (symbol ""Unexpected end of file"")))) (fn _ (((((char.= (car input)) close-parentheses) (fn _ ((((continue ()) path) (cdr input)) (next-char position)))) (fn _ ((((parse-unused path) input) position) (fn path (fn input (fn position ((((parse-expr path) input) position) (fn expr (fn path (fn input (fn position (((((parse-list parse-expr) path) input) position) (fn exprs (fn path (fn input (fn position ((((continue ((cons expr) exprs)) path) input) position))))))))))))))))) ()))) ())))))))
(def parse-expr (fn path (fn input (fn position (fn continue ((with (car input)) (fn head (((((char.= head) open-parentheses) (fn _ (((((parse-list parse-expr) path) (cdr input)) (next-char position)) (fn exprs (fn path (fn input (fn position' ((((continue ((((list-expr exprs) path) position) position')) path) input) position')))))))) (fn _ (((((char.= head) quote) (fn _ ((((parse-symbol-literal path) (cdr input)) (next-char position)) (fn chars (fn path (fn input (fn position' ((((continue ((((symbol-expr chars) path) position) position')) path) input) position')))))))) (fn _ ((((parse-symbol path) input) position) (fn chars (fn path (fn input (fn position' ((((continue ((((symbol-expr chars) path) position) position')) path) input) position')))))))) ()))) ()))))))))
(def repl-parse (fn line (fn index ((((parse-expr ((append line) linefeed)) ((mangle-fn-name (symbol repl)) index)) ((position index) nat.1)) (fn expr (fn path (fn input (fn position expr))))))))
(def parse (fn path (fn input (fn position ((((parse-unused path) input) position) (fn path (fn input (fn position ((((nil? input) (fn _ ())) (fn _ ((((parse-expr path) input) position) (fn expr (fn path (fn input (fn position ((cons expr) (((parse path) input) position))))))))) ())))))))))
(def generate-result.match (fn result (fn degenerate' (fn generating' (fn generated' ((((generated? result) (fn _ (generated' result))) (fn _ ((((generating? result) (fn _ (generating' result))) (fn _ ((((degenerate? result) (fn _ (degenerate' result))) (fn _ (error (symbol ...)))) ()))) ()))) ()))))))
(def as (fn type (fn data (((((is? type) data) (fn _ data)) (fn _ (error ((concat (symbol->list (symbol ""Could not cast ""))) ((concat (symbol->list (type-name data))) ((concat (symbol->list (symbol "" to ""))) (symbol->list type))))))) ()))))
(def field (fn type (fn name (fn data ((second ((as type) data)) name)))))
(def def-declaration.name ((field (symbol def-declaration)) (symbol name)))
(def def-declaration.path ((field (symbol def-declaration)) (symbol path)))
(def put-refs (fn declarations (fn ref-root ((with ((filter declarations) def-declaration?)) (fn def-declarations (((fold def-declarations) (impure ())) (fn process (fn declaration ((then-run process) ((file.write ((file.child ref-root) (normalize (def-declaration.name declaration)))) (def-declaration.path declaration)))))))))))
(def mpm-put-refs (fn declarations ((put-refs declarations) mpm-ref-root)))
(def def-declaration.value ((field (symbol def-declaration)) (symbol value)))
(def fn-declaration.name ((field (symbol fn-declaration)) (symbol name)))
(def declaration.name (fn declaration ((((def-declaration? declaration) (fn _ (def-declaration.name declaration))) (fn _ (fn-declaration.name declaration))) ())))
(def fn-declaration.path ((field (symbol fn-declaration)) (symbol path)))
(def fn-declaration.closures ((field (symbol fn-declaration)) (symbol closures)))
(def fn-declaration.value ((field (symbol fn-declaration)) (symbol value)))
(def declaration.value (fn declaration ((((def-declaration? declaration) (fn _ (def-declaration.value declaration))) (fn _ (fn-declaration.value declaration))) ())))
(def local-env.locals ((field (symbol local-env)) (symbol locals)))
(def local-env.with-def (fn def (fn e ((local-env (local-env.locals e)) def))))
(def local-env.def ((field (symbol local-env)) (symbol def)))
(def local-env.with-locals (fn locals (fn e ((local-env locals) (local-env.def e)))))
(def global-env.globals ((field (symbol global-env)) (symbol globals)))
(def global-env.heap ((field (symbol global-env)) (symbol heap)))
(def global-env.dependents ((field (symbol global-env)) (symbol dependents)))
(def global-env.with-index (fn index (fn e ((((global-env (global-env.globals e)) (global-env.heap e)) (global-env.dependents e)) index))))
(def global-env.index ((field (symbol global-env)) (symbol index)))
(def global-env.with-dependents (fn dependents (fn e ((((global-env (global-env.globals e)) (global-env.heap e)) dependents) (global-env.index e)))))
(def global-env.with-heap (fn heap (fn e ((((global-env (global-env.globals e)) heap) (global-env.dependents e)) (global-env.index e)))))
(def global-env.with-globals (fn globals (fn e ((((global-env globals) (global-env.heap e)) (global-env.dependents e)) (global-env.index e)))))
(def local-variable-operation.name ((field (symbol local-variable-operation)) (symbol name)))
(def desugar-local-variable-operation (fn desugar-operation (fn operation (desugar-quote (local-variable-operation.name operation)))))
(def local-variable-operation.index ((field (symbol local-variable-operation)) (symbol index)))
(def interpret-local-variable-operation (fn interpret-operation' (fn operation (fn stack (fn heap ((get stack) (local-variable-operation.index operation)))))))
(def global-variable-operation.name ((field (symbol global-variable-operation)) (symbol name)))
(def desugar-global-variable-operation (fn desugar-operation (fn operation (desugar-quote (global-variable-operation.name operation)))))
(def global-variable-operation.path ((field (symbol global-variable-operation)) (symbol path)))
(def if-operation.cond ((field (symbol if-operation)) (symbol cond)))
(def if-operation.true ((field (symbol if-operation)) (symbol true)))
(def if-operation.false ((field (symbol if-operation)) (symbol false)))
(def interpret-if-operation (fn interpret-operation' (fn operation (fn stack (fn heap ((((((interpret-operation' (if-operation.cond operation)) stack) heap) (fn _ (((interpret-operation' (if-operation.true operation)) stack) heap))) (fn _ (((interpret-operation' (if-operation.false operation)) stack) heap))) ()))))))
(def def-operation.name ((field (symbol def-operation)) (symbol name)))
(def desugar-def-operation (fn desugar-operation (fn operation (def-operation.name operation))))
(def def-operation.path ((field (symbol def-operation)) (symbol path)))
(def def-operation.value ((field (symbol def-operation)) (symbol value)))
(def fn-operation.path ((field (symbol fn-operation)) (symbol path)))
(def fn-operation.name ((field (symbol fn-operation)) (symbol name)))
(def fn-operation.arg ((field (symbol fn-operation)) (symbol arg)))
(def fn-operation.value ((field (symbol fn-operation)) (symbol value)))
(def desugar-fn-operation (fn desugar-operation (fn operation ((concat (symbol ""(fn "")) ((concat (desugar-quote (fn-operation.arg operation))) ((concat (symbol "" "")) ((concat (desugar-operation (fn-operation.value operation))) (symbol "")""))))))))
(def fn-operation.closures ((field (symbol fn-operation)) (symbol closures)))
(def symbol-operation.name ((field (symbol symbol-operation)) (symbol name)))
(def interpret-symbol-operation (fn interpret-operation' (fn operation (fn stack (fn heap (symbol-operation.name operation))))))
(def desugar-symbol-operation (fn desugar-operation (fn operation ((concat (symbol ""(symbol "")) ((concat (desugar-quote (symbol-operation.name operation))) (symbol "")""))))))
(def apply-operation.fn ((field (symbol apply-operation)) (symbol fn)))
(def apply-operation.arg ((field (symbol apply-operation)) (symbol arg)))
(def interpret-apply-operation (fn interpret-operation' (fn operation (fn stack (fn heap ((((interpret-operation' (apply-operation.fn operation)) stack) heap) (((interpret-operation' (apply-operation.arg operation)) stack) heap)))))))
(def desugar-apply-operation (fn desugar-operation (fn operation ((concat (symbol ""("")) ((concat (desugar-operation (apply-operation.fn operation))) ((concat (symbol "" "")) ((concat (desugar-operation (apply-operation.arg operation))) (symbol "")""))))))))
(def line-number-operation.operation ((field (symbol line-number-operation)) (symbol operation)))
(def desugar-line-number-operation (fn desugar-operation (fn operation (desugar-operation (line-number-operation.operation operation)))))
(def desugar-operation (fn operation ((((with (type-name operation)) (fn type (((((symbol.= type) (symbol local-variable-operation)) (fn _ desugar-local-variable-operation)) (fn _ (((((symbol.= type) (symbol global-variable-operation)) (fn _ desugar-global-variable-operation)) (fn _ (((((symbol.= type) (symbol def-operation)) (fn _ desugar-def-operation)) (fn _ (((((symbol.= type) (symbol fn-operation)) (fn _ desugar-fn-operation)) (fn _ (((((symbol.= type) (symbol symbol-operation)) (fn _ desugar-symbol-operation)) (fn _ (((((symbol.= type) (symbol apply-operation)) (fn _ desugar-apply-operation)) (fn _ (((((symbol.= type) (symbol line-number-operation)) (fn _ desugar-line-number-operation)) (fn _ (((((symbol.= type) (symbol nil-operation)) (fn _ desugar-nil-operation)) (fn _ (error (symbol ...)))) ()))) ()))) ()))) ()))) ()))) ()))) ()))) ()))) desugar-operation) operation)))
(def desugar-def-declaration (fn declaration ((concat (symbol ""(def "")) ((concat (desugar-quote (def-declaration.name declaration))) ((concat (symbol "" "")) ((concat (desugar-operation (def-declaration.value declaration))) ((append (symbol "")"")) linefeed)))))))
(def desugar-declaration (fn declaration (((with (type-name declaration)) (fn type (((((symbol.= type) (symbol def-declaration)) (fn _ desugar-def-declaration)) (fn _ (((((symbol.= type) (symbol fn-declaration)) (fn _ desugar-fn-declaration)) (fn _ (error (symbol ...)))) ()))) ()))) declaration)))
(def desugar-declarations (fn declarations ((flat-map declarations) desugar-declaration)))
(def m-backend (fn out (fn operation (fn declarations ((with (desugar-declarations declarations)) (fn desugared ((file.write out) desugared)))))))
(def get-backend (fn name (((((symbol.= name) (symbol m)) (fn _ m-backend)) (fn _ (((((symbol.= name) (symbol jvm)) (fn _ jvm-backend)) (fn _ (error ((concat (symbol ""Could not find backend "")) name)))) ()))) ())))
(def interpret-line-number-operation (fn interpret-operation' (fn operation (interpret-operation' (line-number-operation.operation operation)))))
(def operation.fold (fn operation (fn acc (fn f ((f ((with (type-name operation)) (fn type (((((symbol.= type) (symbol local-variable-operation)) (fn _ acc)) (fn _ (((((symbol.= type) (symbol global-variable-operation)) (fn _ acc)) (fn _ (((((symbol.= type) (symbol if-operation)) (fn _ (((operation.fold (if-operation.false operation)) (((operation.fold (if-operation.true operation)) (((operation.fold (if-operation.cond operation)) acc) f)) f)) f))) (fn _ (((((symbol.= type) (symbol def-operation)) (fn _ (((operation.fold (def-operation.value operation)) acc) f))) (fn _ (((((symbol.= type) (symbol fn-operation)) (fn _ (((operation.fold (fn-operation.value operation)) acc) f))) (fn _ (((((symbol.= type) (symbol symbol-operation)) (fn _ acc)) (fn _ (((((symbol.= type) (symbol apply-operation)) (fn _ (((operation.fold (apply-operation.arg operation)) (((operation.fold (apply-operation.fn operation)) acc) f)) f))) (fn _ (((((symbol.= type) (symbol line-number-operation)) (fn _ (((operation.fold (line-number-operation.operation operation)) acc) f))) (fn _ (((((symbol.= type) (symbol nil-operation)) (fn _ acc)) (fn _ (error (symbol ...)))) ()))) ()))) ()))) ()))) ()))) ()))) ()))) ()))) ())))) operation)))))
(def line-number-operation.line ((field (symbol line-number-operation)) (symbol line)))
(def local-variable.name ((field (symbol local-variable)) (symbol name)))
(def local-variable.index ((field (symbol local-variable)) (symbol index)))
(def global-variable.name ((field (symbol global-variable)) (symbol name)))
(def global-variable.path ((field (symbol global-variable)) (symbol path)))
(def generate-symbol-expr' (fn variable ((((global-variable? variable) (fn _ ((global-variable-operation (global-variable.name variable)) (global-variable.path variable)))) (fn _ ((local-variable-operation (local-variable.name variable)) (local-variable.index variable)))) ())))
(def global-variable.macro? ((field (symbol global-variable)) (symbol macro?)))
(def generating.dependencies ((field (symbol generating)) (symbol dependencies)))
(def generating.global-env ((field (symbol generating)) (symbol global-env)))
(def generating.continue ((field (symbol generating)) (symbol continue)))
(def generated-resolve-generating (fn generated.combine (fn generated' (fn generating' (fn global-env (fn f (((generating (generating.dependencies generating')) global-env) (fn global-env ((((generated.combine generated') ((generating.continue generating') global-env)) global-env) f)))))))))
(def generated.operation ((field (symbol generated)) (symbol operation)))
(def generated.declarations ((field (symbol generated)) (symbol declarations)))
(def generated.global-env ((field (symbol generated)) (symbol global-env)))
(def degenerate.errors ((field (symbol degenerate)) (symbol errors)))
(def degenerate.with-global-env (fn env (fn degenerate' ((degenerate (degenerate.errors degenerate')) env))))
(def generated.combine (fn generated1 (fn result (fn global-env (fn f ((((generate-result.match result) (fn degenerate2 ((degenerate.with-global-env global-env) degenerate2))) (fn generating2 (((((generated-resolve-generating generated.combine) generated1) generating2) global-env) f))) (fn generated2 (((generated ((f (generated.operation generated1)) (generated.operation generated2))) ((concat (generated.declarations generated1)) (generated.declarations generated2))) global-env))))))))
(def generating.combine (fn generating1 (fn result (fn global-env (fn f ((((generate-result.match result) (fn degenerate2 ((degenerate.with-global-env global-env) degenerate2))) (fn generating2 (((generating ((concat (generating.dependencies generating1)) (generating.dependencies generating2))) global-env) (fn global-env ((((generating.combine generating1) generating2) global-env) f))))) (fn generated2 (((((generated-resolve-generating generated.combine) generated2) generating1) global-env) (swap f)))))))))
(def degenerate.combine (fn degenerate1 (fn result (fn global-env (fn f ((((generate-result.match result) (fn degenerate2 ((degenerate ((concat (degenerate.errors degenerate1)) (degenerate.errors degenerate2))) global-env))) (fn generating2 ((degenerate.with-global-env global-env) degenerate1))) (fn generated2 ((degenerate.with-global-env global-env) degenerate1))))))))
(def generate-result.combine (fn result1 (fn result2 (fn global-env (fn f ((((generate-result.match result1) (fn degenerate1 ((((degenerate.combine degenerate1) result2) global-env) f))) (fn generating1 ((((generating.combine generating1) result2) global-env) f))) (fn generated1 ((((generated.combine generated1) result2) global-env) f))))))))
(def write-result (fn backend (fn result (fn out ((((generate-result.match result) (fn degenerate' (impure (error (car (degenerate.errors degenerate')))))) (fn generating' (impure (error ((flat-map (generating.dependencies generating')) ((swap append) space)))))) (fn generated' (((backend out) (generated.operation generated')) (generated.declarations generated'))))))))
(def degenerate.global-env ((field (symbol degenerate)) (symbol global-env)))
(def generate-result.global-env (fn result ((((generate-result.match result) degenerate.global-env) generating.global-env) generated.global-env)))
(def generate-apply-expr' (fn fn-result (fn arg-result ((((generate-result.combine fn-result) arg-result) (generate-result.global-env arg-result)) apply-operation))))
(def generate-apply-expr (fn generate-expr (fn fn (fn args (fn local-env (fn global-env ((with (((generate-expr fn) local-env) global-env)) (fn fn-result (((fold args) fn-result) (fn fn-result (fn arg ((with (((generate-expr arg) local-env) (generate-result.global-env fn-result))) (fn arg-result ((generate-apply-expr' fn-result) arg-result))))))))))))))
(def tree-map-node.left ((field (symbol tree-map-node)) (symbol left)))
(def tree-map-node.min-node (fn node ((((tree-map-node-nil? (tree-map-node.left node)) (fn _ node)) (fn _ (tree-map-node.min-node (tree-map-node.left node)))) ())))
(def tree-map-node.right ((field (symbol tree-map-node)) (symbol right)))
(def tree-map-node.key ((field (symbol tree-map-node)) (symbol key)))
(def tree-map-node.value ((field (symbol tree-map-node)) (symbol value)))
(def tree-map-node.get (fn node (fn compare (fn key ((((tree-map-node-nil? node) (fn _ null)) (fn _ ((((fold-compare ((compare key) (tree-map-node.key node))) (fn < (((tree-map-node.get (tree-map-node.left node)) compare) key))) (fn > (((tree-map-node.get (tree-map-node.right node)) compare) key))) (fn = (some (tree-map-node.value node)))))) ())))))
(def tree-map-node.remove (fn node (fn compare (fn key ((((tree-map-node-nil? node) (fn _ node)) (fn _ ((((fold-compare ((compare key) (tree-map-node.key node))) (fn < ((((tree-map-node (((tree-map-node.remove (tree-map-node.left node)) compare) key)) (tree-map-node.right node)) (tree-map-node.key node)) (tree-map-node.value node)))) (fn > ((((tree-map-node (tree-map-node.left node)) (((tree-map-node.remove (tree-map-node.right node)) compare) key)) (tree-map-node.key node)) (tree-map-node.value node)))) (fn = ((((tree-map-node-nil? (tree-map-node.left node)) (fn _ (tree-map-node.right node))) (fn _ ((((tree-map-node-nil? (tree-map-node.right node)) (fn _ (tree-map-node.left node))) (fn _ ((with (tree-map-node.min-node (tree-map-node.right node))) (fn min ((((tree-map-node (tree-map-node.left node)) (tree-map-node.right (((tree-map-node.remove (tree-map-node.right node)) compare) key))) (tree-map-node.key min)) (tree-map-node.value min)))))) ()))) ()))))) ())))))
(def tree-map-node.put (fn node (fn compare (fn key (fn value ((((tree-map-node-nil? node) (fn _ ((((tree-map-node tree-map-node-nil) tree-map-node-nil) key) value))) (fn _ ((((fold-compare ((compare key) (tree-map-node.key node))) (fn < ((((tree-map-node ((((tree-map-node.put (tree-map-node.left node)) compare) key) value)) (tree-map-node.right node)) (tree-map-node.key node)) (tree-map-node.value node)))) (fn > ((((tree-map-node (tree-map-node.left node)) ((((tree-map-node.put (tree-map-node.right node)) compare) key) value)) (tree-map-node.key node)) (tree-map-node.value node)))) (fn = ((((tree-map-node (tree-map-node.left node)) (tree-map-node.right node)) key) value))))) ()))))))
(def tree-map-node.fold (fn node (fn acc (fn f ((((tree-map-node-nil? node) (fn _ acc)) (fn _ (((tree-map-node.fold (tree-map-node.right node)) (((f (((tree-map-node.fold (tree-map-node.left node)) acc) f)) (tree-map-node.key node)) (tree-map-node.value node))) f))) ())))))
(def tree-map.node ((field (symbol tree-map)) (symbol node)))
(def tree-map.fold (fn map (fn acc (fn f (((tree-map-node.fold (tree-map.node map)) acc) f)))))
(def tree-map->list (fn map (((tree-map.fold map) ()) (fn list (fn key (fn value ((cons ((pair key) value)) list)))))))
(def tree-map.compare ((field (symbol tree-map)) (symbol compare)))
(def tree-map.get (fn map (fn key (((tree-map-node.get (tree-map.node map)) (tree-map.compare map)) key))))
(def env.get (fn local-env (fn global-env (fn name ((with ((tree-map.get (local-env.locals local-env)) name)) (fn option ((((some? option) (fn _ option)) (fn _ ((tree-map.get (global-env.globals global-env)) name))) ())))))))
(def generate-symbol-expr (fn name (fn local-env (fn global-env ((with (((env.get local-env) global-env) name)) (fn option ((((some? option) (fn _ (((generated (generate-symbol-expr' (unnull option))) ()) global-env))) (fn _ (((generating ((cons name) ())) global-env) (fn global-env (((generate-symbol-expr name) local-env) global-env))))) ())))))))
(def global-env->env (fn global-env (fn name ((pair ((pair ((global-env.heap global-env) name)) null)) ((((tree-map.get (global-env.globals global-env)) name) (const null)) global-variable.macro?)))))
(def global-env.unresolved (fn global-env ((filter ((map (tree-map->list (global-env.dependents global-env))) first)) (fn dependent (null? ((tree-map.get (global-env.globals global-env)) dependent))))))
(def tree-map.remove (fn map (fn key ((tree-map (((tree-map-node.remove (tree-map.node map)) (tree-map.compare map)) key)) (tree-map.compare map)))))
(def tree-map.put (fn map (fn key (fn value ((tree-map ((((tree-map-node.put (tree-map.node map)) (tree-map.compare map)) key) value)) (tree-map.compare map))))))
(def file->tree-map' (fn path (fn !tree-map (fn file ((then-run-with (file.directory? file)) (fn directory? (((directory? (fn _ ((then-run-with (file.child-files file)) (fn child-files (((fold child-files) !tree-map) (file->tree-map' ((append path) (file.name file)))))))) (fn _ ((then-run-with !tree-map) (fn tree-map (impure (((tree-map.put tree-map) ((append path) (file.name file))) file)))))) ())))))))
(def file->tree-map (fn file (((file->tree-map' ()) (impure (empty-tree-map (compare-list compare-symbol)))) file)))
(def parse-file (fn file ((then-run-with (file->tree-map file)) (fn tree-map ((then-run-with (file.directory? file)) (fn directory? (((tree-map.fold tree-map) (impure ())) (fn !acc (fn path (fn file ((then-run-with (file.read file)) (fn chars ((then-run-with !acc) (fn acc (impure ((concat acc) (((parse (init (init (cdr ((flat-map (((directory? (fn _ (cdr path))) (fn _ path)) ())) (cons slash)))))) chars) ((position nat.1) nat.1))))))))))))))))))
(def generate-fn-expr-closures (fn closures (fn name (fn local-env (second (((fold ((append closures) name)) ((pair nat.0) (local-env.locals local-env))) (fn vars (fn closure ((pair ((nat.+ nat.1) (first vars))) (((tree-map.put (second vars)) closure) ((local-variable closure) (first vars))))))))))))
(def generating->generated (fn generating' (fn operation (fn global-env (fn continue (((generated operation) ()) (((swap global-env.with-dependents) global-env) ((with (global-env.dependents (generating.global-env generating'))) (fn dependents ((with (car (generating.dependencies generating'))) (fn dependency (((tree-map.put dependents) dependency) (fn global-env ((((null? ((tree-map.get dependents) dependency)) (fn _ (continue global-env))) (fn _ ((with ((unnull ((tree-map.get dependents) dependency)) global-env)) (fn result1 ((with (continue (generate-result.global-env result1))) (fn result2 ((((generate-result.combine result1) result2) (generate-result.global-env result2)) false))))))) ()))))))))))))))
(def tree-map.+ (fn a (fn b (((tree-map.fold a) b) (fn map (fn key (fn value (((tree-map.put map) key) value))))))))
(def closures' (fn local-env (fn acc (fn expr ((((symbol-expr? expr) (fn _ ((((null? ((tree-map.get (local-env.locals local-env)) (symbol-expr.name expr))) (fn _ acc)) (fn _ (((tree-map.put acc) (symbol-expr.name expr)) true))) ()))) (fn _ (((fold (list-expr.exprs expr)) acc) (closures' local-env)))) ())))))
(def closures (fn local-env ((closures' local-env) (empty-tree-map compare-symbol))))
(def heap.get (fn heap (fn name ((with (heap name)) (fn value ((((null? value) (fn _ (error ((concat (symbol->list (symbol ""Could not find ""))) name)))) (fn _ ((unnull value) heap))) ()))))))
(def interpret-global-variable-operation (fn interpret-operation' (fn operation (fn stack (fn heap ((heap.get heap) (global-variable-operation.name operation)))))))
(def interpret-def-operation (fn interpret-operation' (fn operation (fn stack (fn heap ((heap.get heap) (def-operation.name operation)))))))
(def interpret-fn-operation (fn interpret-operation' (fn operation (fn stack (fn heap (fn arg (((heap.get heap) (fn-operation.name operation)) ((concat ((map (fn-operation.closures operation)) (fn closure (((interpret-operation' closure) stack) heap)))) ((cons arg) stack)))))))))
(def interpret-operation' (fn operation (fn stack (fn heap ((((((with (type-name operation)) (fn type (((((symbol.= type) (symbol local-variable-operation)) (fn _ interpret-local-variable-operation)) (fn _ (((((symbol.= type) (symbol global-variable-operation)) (fn _ interpret-global-variable-operation)) (fn _ (((((symbol.= type) (symbol if-operation)) (fn _ interpret-if-operation)) (fn _ (((((symbol.= type) (symbol def-operation)) (fn _ interpret-def-operation)) (fn _ (((((symbol.= type) (symbol fn-operation)) (fn _ interpret-fn-operation)) (fn _ (((((symbol.= type) (symbol symbol-operation)) (fn _ interpret-symbol-operation)) (fn _ (((((symbol.= type) (symbol apply-operation)) (fn _ interpret-apply-operation)) (fn _ (((((symbol.= type) (symbol line-number-operation)) (fn _ interpret-line-number-operation)) (fn _ (((((symbol.= type) (symbol nil-operation)) (fn _ interpret-nil-operation)) (fn _ (error (symbol ...)))) ()))) ()))) ()))) ()))) ()))) ()))) ()))) ()))) ()))) interpret-operation') operation) stack) heap)))))
(def interpret-operation (fn operation (fn heap (((interpret-operation' operation) ()) heap))))
(def repl-interpret-operation (fn result (fn heap ((interpret-operation (generated.operation result)) heap))))
(def interpret-def-declaration (fn declaration (fn heap (fn name (((((symbol.= name) (def-declaration.name declaration)) (fn _ (some (fn heap' ((interpret-operation (def-declaration.value declaration)) heap'))))) (fn _ (heap name))) ())))))
(def generate-global-expr' (fn name (fn value (fn declaration (fn generated' (((generated (((def-operation name) (expr.path value)) (generated.operation generated'))) ((append (generated.declarations generated')) declaration)) (((swap global-env.with-heap) (generated.global-env generated')) ((interpret-def-declaration declaration) (global-env.heap (generated.global-env generated'))))))))))
(def generate-global-expr (fn macro? (fn generate-expr (fn name (fn value (fn local-env (fn global-env ((((some? ((tree-map.get (global-env.globals global-env)) name)) (fn _ ((degenerate ((cons ((concat name) (symbol "" has already been defined""))) ())) global-env))) (fn _ ((with (((swap global-env.with-globals) global-env) (((tree-map.put (global-env.globals global-env)) name) (((global-variable name) (expr.path value)) macro?)))) (fn new-global-env ((((generate-result.match (((generate-expr value) ((local-env.with-def name) local-env)) new-global-env)) (fn degenerate' degenerate')) (fn generating' ((((generating->generated generating') (((def-operation name) (expr.path value)) nil-operation)) global-env) (fn global-env ((((((generate-global-expr macro?) generate-expr) name) value) local-env) global-env))))) (fn generated' ((with (((def-declaration name) (expr.path value)) (generated.operation generated'))) (fn declaration ((with ((tree-map.get (global-env.dependents (generated.global-env generated'))) name)) (fn generating? ((with ((((generate-global-expr' name) value) declaration) generated')) (fn result1 ((with ((unnull generating?) (generated.global-env result1))) (fn result2 ((((null? generating?) (fn _ result1)) (fn _ ((((generated.combine result1) result2) (generate-result.global-env result2)) true))) ()))))))))))))))) ()))))))))
(def generate-def-expr (generate-global-expr false))
(def generate-macro-expr (generate-global-expr true))
(def interpret-fn-declaration (fn declaration (fn heap (fn name (((((symbol.= name) (fn-declaration.name declaration)) (fn _ (some (fn heap' (fn stack (((interpret-operation' (fn-declaration.value declaration)) stack) heap')))))) (fn _ (heap name))) ())))))
(def generate-fn-expr' (fn generate-expr (fn name (fn value (fn local-env (fn global-env ((with ((mangle-fn-name (local-env.def local-env)) (global-env.index global-env))) (fn mangled-name ((with ((global-env.with-index ((nat.+ nat.1) (global-env.index global-env))) global-env)) (fn new-global-env ((with ((map (tree-map->list ((closures local-env) value))) first)) (fn closures ((((generate-result.match (((generate-expr value) ((local-env.with-locals (((generate-fn-expr-closures closures) name) local-env)) ((local-env.with-def mangled-name) local-env))) new-global-env)) (fn degenerate' degenerate')) (fn generating' (((generating (generating.dependencies generating')) (generating.global-env generating')) (fn global-env ((((generate-fn-expr' name) value) local-env) global-env))))) (fn generated' ((with ((((fn-declaration mangled-name) (expr.path value)) closures) (generated.operation generated'))) (fn declaration (((generated (((((fn-operation (expr.path value)) mangled-name) name) (generated.operation generated')) ((map closures) (fn closure (generate-symbol-expr' (unnull (((env.get local-env) (generated.global-env generated')) closure))))))) ((append (generated.declarations generated')) declaration)) (((swap global-env.with-heap) (generated.global-env generated')) ((interpret-fn-declaration declaration) (global-env.heap (generated.global-env generated')))))))))))))))))))))
(def generate-fn-expr (fn generate-expr (fn names (fn value (fn local-env (fn global-env ((((nil? (cdr names)) (fn _ (((((generate-fn-expr' generate-expr) (car names)) value) local-env) global-env))) (fn _ ((with ((((list-expr ((cons ((((symbol-expr (symbol fn)) (expr.path value)) (expr.start value)) (expr.end value))) ((cons ((((symbol-expr (last names)) (expr.path value)) (expr.start value)) (expr.end value))) ((cons value) ())))) (expr.path value)) (expr.start value)) (expr.end value))) (fn new-value (((((generate-fn-expr generate-expr) (init names)) new-value) local-env) global-env))))) ())))))))
(def interpret-declaration (fn declaration (fn heap ((((with (type-name declaration)) (fn type (((((symbol.= type) (symbol def-declaration)) (fn _ interpret-def-declaration)) (fn _ (((((symbol.= type) (symbol fn-declaration)) (fn _ interpret-fn-declaration)) (fn _ (error (symbol ...)))) ()))) ()))) declaration) heap))))
(def interpret-declarations (fn declarations (fn heap (((fold declarations) heap) (fn heap' (fn declaration ((interpret-declaration declaration) heap')))))))
(def repl-interpret-declarations (fn result (fn heap ((interpret-declarations (generated.declarations result)) heap))))
(def generate-macro-apply-expr (fn generate-expr (fn expr (fn name (fn args (fn local-env (fn global-env ((with ((heap.get (global-env.heap global-env)) name)) (fn function ((with (global-env->env global-env)) (fn env ((with ((function env) args)) (fn result ((((result/match result) (fn new-expr (((generate-expr ((expr.with-path (expr.path expr)) new-expr)) local-env) global-env))) (fn errors ((degenerate errors) global-env))) (fn dependencies (((generating dependencies) global-env) (fn global-env ((((((generate-macro-apply-expr generate-expr) expr) name) args) local-env) global-env))))))))))))))))))
(def generate-macro?-expr (fn generate-expr (fn expr (fn fn (fn args (fn local-env (fn global-env ((with (symbol-expr.name fn)) (fn name ((with (((env.get local-env) global-env) name)) (fn option ((((null? option) (fn _ (((generating ((cons name) ())) global-env) (fn global-env (((((generate-macro?-expr expr) fn) args) local-env) global-env))))) (fn _ ((with (unnull option)) (fn variable (((((and (global-variable? variable)) (fn _ (global-variable.macro? variable))) (fn _ ((((((generate-macro-apply-expr generate-expr) expr) name) args) local-env) global-env))) (fn _ (((((generate-apply-expr generate-expr) fn) args) local-env) global-env))) ()))))) ()))))))))))))
(def generate-list-expr (fn generate-expr (fn expr (fn local-env (fn global-env ((with (list-expr.exprs expr)) (fn exprs ((((nil? exprs) (fn _ ((generate-nil local-env) global-env))) (fn _ ((((symbol-expr? (car exprs)) (fn _ ((with (symbol-expr.name (car exprs))) (fn name ((((((compose ((list.= char.=) name)) symbol->list) (symbol fn)) (fn _ (((((generate-fn-expr generate-expr) ((map (init (cdr exprs))) symbol-expr.name)) (last exprs)) local-env) global-env))) (fn _ ((((((compose ((list.= char.=) name)) symbol->list) (symbol def)) (fn _ (((((generate-def-expr generate-expr) (symbol-expr.name (cadr exprs))) (caddr exprs)) local-env) global-env))) (fn _ ((((((compose ((list.= char.=) name)) symbol->list) (symbol macro)) (fn _ (((((generate-macro-expr generate-expr) (symbol-expr.name (cadr exprs))) (caddr exprs)) local-env) global-env))) (fn _ ((((((compose ((list.= char.=) name)) symbol->list) (symbol symbol)) (fn _ (((generate-symbol-literal-expr (symbol-expr.name (cadr exprs))) local-env) global-env))) (fn _ ((((((generate-macro?-expr generate-expr) expr) (car exprs)) (cdr exprs)) local-env) global-env))) ()))) ()))) ()))) ()))))) (fn _ (((((generate-apply-expr generate-expr) (car exprs)) (cdr exprs)) local-env) global-env))) ()))) ()))))))))
(def generate-expr (fn expr (fn local-env (fn global-env ((((generate-result.match ((((symbol-expr? expr) (fn _ (((generate-symbol-expr (symbol-expr.name expr)) local-env) global-env))) (fn _ ((((generate-list-expr generate-expr) expr) local-env) global-env))) ())) (fn degenerate' degenerate')) (fn generating' generating')) (fn generated' (((generated ((line-number-operation (generated.operation generated')) (position.line (expr.start expr)))) (generated.declarations generated')) (generated.global-env generated'))))))))
(def generate-exprs' (fn exprs (fn result ((((nil? exprs) (fn _ result)) (fn _ ((with ((((generate-result.match (((generate-expr (car exprs)) default-local-env) (generate-result.global-env result))) (fn degenerate' degenerate')) (fn generating' ((((generating->generated generating') nil-operation) (generate-result.global-env result)) (fn global-env (((generate-expr (car exprs)) default-local-env) global-env))))) (fn generated' generated'))) (fn car-result ((generate-exprs' (cdr exprs)) ((((generate-result.combine result) car-result) (generate-result.global-env car-result)) true)))))) ()))))
(def generate-exprs (fn exprs (fn global-env ((generate-exprs' exprs) (((generated nil-operation) ()) global-env)))))
(def resolve-dependencies (fn root (fn resolve (fn resolved (fn result (fn dependencies (fn indef ((with (get-src (src-root root))) (fn src-of-ref ((with (get-ref (ref-root root))) (fn ref-of-sym ((((nil? dependencies) (fn _ ((with (((indef (fn _ result)) (fn _ ((degenerate ((cons (symbol ""Could not resolve dependencies"")) ())) (generate-result.global-env result)))) ())) (fn result (impure ((pair resolved) result)))))) (fn _ ((with (ref-of-sym (car dependencies))) (fn ref-file ((then-run-with (file.exists? ref-file)) (fn is-ref ((((not is-ref) (fn _ ((((((resolve-dependencies root) resolve) resolved) result) (cdr dependencies)) indef))) (fn _ ((then-run-with (file.read ref-file)) (fn ref ((((some? ((tree-map.get resolved) ref)) (fn _ ((((((resolve-dependencies root) resolve) resolved) result) (cdr dependencies)) true))) (fn _ ((then-run-with (parse-file (src-of-ref ref))) (fn exprs ((then-run-with ((resolve (((tree-map.put resolved) ref) true)) ((generate-exprs' exprs) result))) (fn pair ((((((resolve-dependencies root) resolve) (first pair)) (second pair)) (cdr dependencies)) true))))))) ()))))) ()))))))) ()))))))))))))
(def mpm-resolve-dependencies (resolve-dependencies mpm-root))
(def mpm-resolve-generating (fn resolve (fn resolved (fn generating' ((then-run-with (((((mpm-resolve-dependencies resolve) resolved) generating') (generating.dependencies generating')) false)) (fn pair ((resolve (first pair)) (second pair))))))))
(def mpm-resolve-generated (fn resolve (fn resolved (fn generated' ((with (global-env.unresolved (generated.global-env generated'))) (fn unresolved ((((nil? unresolved) (fn _ (impure ((pair resolved) generated')))) (fn _ ((then-run-with (((((mpm-resolve-dependencies resolve) resolved) generated') unresolved) false)) (fn pair ((resolve (first pair)) (second pair)))))) ())))))))
(def mpm-resolve-generate-result' (fn resolved (fn result ((((generate-result.match result) (fn degenerate' (impure ((pair resolved) degenerate')))) ((mpm-resolve-generating mpm-resolve-generate-result') resolved)) ((mpm-resolve-generated mpm-resolve-generate-result') resolved)))))
(def mpm-resolve-generate-result (fn result (((swap run-with) second) ((mpm-resolve-generate-result' (empty-tree-map compare-symbol)) result))))
(def generate (fn exprs (mpm-resolve-generate-result ((generate-exprs exprs) default-global-env))))
(def run-mpm-put (fn args ((with ((file.child file.local-file) (car args))) (fn file ((then-run-with (parse-file file)) (fn exprs ((then-run-with (generate exprs)) (fn result ((then-run (mpm-put-refs (generated.declarations result))) (mpm-put-srcs file))))))))))
(def run-compile (fn args ((with (get-backend (car args))) (fn backend ((with ((file.child file.local-file) (cadr args))) (fn in ((with ((file.child file.local-file) (caddr args))) (fn out ((then-run-with (parse-file in)) (fn exprs ((then-run-with (generate exprs)) (fn result (((write-result backend) result) out)))))))))))))
(def repl (fn global-env (fn heap (fn index (fn resolved ((then-run-with ((then-run ((ostream.write stdout) (car (symbol >)))) (istream.readln stdin))) (fn line (((((symbol.= ((filter line) ((compose not) whitespace?))) ()) (fn _ (impure ()))) (fn _ ((with ((char.= (car line)) (car (symbol !)))) (fn !? ((with ((repl-parse ((concat (symbol ""(def it "")) ((append (((!? (fn _ (cdr line))) (fn _ line)) ())) close-parentheses))) index)) (fn expr ((then-run-with ((mpm-resolve-generate-result' resolved) (((generate-expr expr) default-local-env) global-env))) (fn pair ((with ((repl-interpret-declarations (second pair)) heap)) (fn new-heap ((with ((repl-interpret-operation (second pair)) new-heap)) (fn value (((((!? (fn _ then-run-with)) (fn _ with)) ()) value) (fn v ((((((const repl) (debug v)) ((global-env.with-globals ((tree-map.remove (global-env.globals (generated.global-env (second pair)))) (symbol it))) (generated.global-env (second pair)))) new-heap) (nat.inc index)) (first pair)))))))))))))))) ()))))))))
(def run-repl (fn args ((with ((file.child file.local-file) (car args))) (fn file ((then-run-with (parse-file file)) (fn exprs ((then-run-with (generate exprs)) (fn result ((((repl (generated.global-env result)) ((interpret-declarations (generated.declarations result)) empty-heap)) nat.1) (empty-tree-map compare-symbol))))))))))
(def """" (fn args ((with (car args)) (fn mode (((((symbol.= mode) (symbol repl)) (fn _ (run-repl (cdr args)))) (fn _ (((((symbol.= mode) (symbol compile)) (fn _ (run-compile (cdr args)))) (fn _ (((((symbol.= mode) (symbol mpm-put)) (fn _ (run-mpm-put (cdr args)))) (fn _ (error ((concat (symbol ""Could not find mode "")) mode)))) ()))) ()))) ())))))
